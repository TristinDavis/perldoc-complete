#!/usr/bin/env perl
use strict;
use File::Spec::Functions qw( rel2abs catdir no_upwards );

sub uniq { my %seen; grep { not $seen{$_}++ } @_ }

sub get_completion_word {
	my $comp = substr $ENV{'COMP_LINE'}, 0, $ENV{'COMP_POINT'};
	$comp =~ s/.*[ \t]//;
	return $comp;
}

sub slurp_dir {
	opendir my $dir, shift or return;
	no_upwards readdir $dir;
}

sub suggestion_from_name {
	my ( $file_rx, $path, $name ) = @_;
	return if not $name =~ /$file_rx/;
	return $name.'::' if -d catdir $path, $name;
	return $1;
}

sub suggestions_from_path {
	my ( $file_rx, $path ) = @_;
	map { suggestion_from_name $file_rx, $path, $_ } slurp_dir $path;
}

sub usage {
	die map "\n$_\n", (
		"To use, issue the following command in bash:",
		"\tcomplete -C perldoc-complete perldoc",
		"You probably want to put that line in your ~/.bashrc file.\n",
	);
}

usage() if not exists $ENV{'COMP_LINE'};

my $pkg = get_completion_word();
my @segment = split /::|:\z/, $pkg, -1;
my $file_rx = qr/\A(${\quotemeta pop @segment}\w*)(?:\.pm|\.pod)?\z/;

my $home = rel2abs $ENV{'HOME'};

# if the package ended in a single colon,
# then prepend a colon to all suggestions
my ( $pfx ) = $pkg =~ /(?<!:)(:)\z/;

my @src = @INC;

if ( $pkg =~ /^perl/ ) {
	$_ = catdir $_, 'pod' for @src;
}

my @suggestion =
	uniq sort map { suggestions_from_path $file_rx, $_ }
	uniq map { catdir $_, @segment }
	grep { $home ne rel2abs $_ }
	@src;

# if there is only one completion, bash will take that and append a space,
# but after completing to Foo:: we want bash to leave the caret right there
# so we make up an extra 'Foo:: ' suggestion to create artificial ambiguity
if ( 1 == @suggestion and $suggestion[0] =~ /::\z/ ) {
	push @suggestion, $suggestion[0] . ' ';
}

print "$pfx$_\n" for @suggestion;
